import { existsSync } from 'fs';
import * as path from 'path';
import {
  CancellationToken,
  DebugAdapterDescriptor,
  DebugAdapterDescriptorFactory,
  DebugAdapterInlineImplementation,
  DebugConfiguration,
  DebugConfigurationProvider,
  DebugSession,
  ExtensionContext,
  ProviderResult,
  WorkspaceFolder,
  debug,
  languages,
  window,
} from 'vscode';
import { isArray, isBoolean, isPlainObject } from 'ts-predicates';
import { defaults, isString, range } from 'underscore';
import * as isPortTaken from 'is-port-taken';
import { getAhkVersion } from './util/getAhkVersion';
import { completionItemProvider } from './CompletionItemProvider';
import { AhkDebugSession } from './ahkDebug';

class AhkConfigurationProvider implements DebugConfigurationProvider {
  private pendingErrors: Error[] = []; // The error message is not displayed when an error occurs with `resolveDebugConfigurationWithSubstitutedVariables`. Therefore, we save the error and cause it to be generated by the `resolveDebugConfigurationWithSubstitutedVariables`
  public async resolveDebugConfiguration(folder: WorkspaceFolder | undefined, config: DebugConfiguration, token?: CancellationToken): Promise<DebugConfiguration> {
    this.pendingErrors = [];

    const defaultConfig = {
      name: 'AutoHotkey Debug',
      type: 'autohotkey',
      request: 'launch',
      runtime_v1: 'AutoHotkey.exe',
      runtime_v2: 'v2/AutoHotkey.exe',
      hostname: 'localhost',
      port: 9000,
      program: '${file}',
      args: [],
      env: {},
      permittedPortRange: [],
      // If a value greater than 10000 is specified, malfunction may occur due to specification changes.
      // Ref: https://github.com/Lexikos/AutoHotkey_L/blob/36600809a348bd3a09d59e335d2897ed16f11ac7/source/Debugger.cpp#L960
      // > TODO: Include the lazy-var arrays for completeness. Low priority since lazy-var arrays are used only for 10001+ variables, and most conventional debugger interfaces would generally not be useful with that many variables.
      stopOnEntry: false,
      maxChildren: 10000,
      openFileOnExit: null,
      useIntelliSenseInDebugging: true,
      usePerfTips: false,
      useDebugDirective: false,
      trace: false,
    };
    defaults(config, defaultConfig);

    // init request
    ((): void => {
      if (config.request === 'launch') {
        return;
      }

      const commonErrorMessage = '`type` must be "launch".';
      if (config.request === 'attach') {
        this.pendingErrors.push(Error(`${commonErrorMessage} "attach" is not supported.`));
        return;
      }
      this.pendingErrors.push(Error(commonErrorMessage));
    })();

    // init hostname
    ((): void => {
      if (!isString(config.hostname)) {
        this.pendingErrors.push(Error('`hostname` must be a string.'));
      }
    })();

    // init port
    await (async(): Promise<void> => {
      const portRange = ((): { permitted: boolean; range: number[] } | Error => {
        const createUnPermittedPortRange = (port: number): { permitted: boolean; range: number[] } => {
          return { permitted: false, range: range(port, port + 100) };
        };

        if (Number.isInteger(config.port)) {
          return createUnPermittedPortRange(config.port as number);
        }
        else if (typeof config.port === 'string') {
          if (config.port.match(/^\d+$/u)) {
            return createUnPermittedPortRange(parseInt(config.port, 10));
          }

          const errorMessage = 'It must be specified in the format of "start-last". It must be start < last. e.g. "9000-9010"';
          const match = config.port.match(/^(?<start>\d+)-(?<last>\d+)$/u);
          if (!match) {
            return Error(errorMessage);
          }
          if (!match.groups) {
            return Error(errorMessage);
          }

          const start = parseInt(match.groups.start, 10);
          const last = parseInt(match.groups.last, 10);
          if (isNaN(start) || isNaN(last)) {
            return Error(errorMessage);
          }
          if (start === last) {
            return Error(errorMessage);
          }
          if (last <= start) {
            return Error(errorMessage);
          }
          return { permitted: true, range: range(start, last + 1) };
        }

        return Error('`port` must be a number or a string of `start-last` format. e.g. "9000-9010"');
      })();

      if (portRange instanceof Error) {
        this.pendingErrors.push(portRange);
        return;
      }

      for await (const port of portRange.range) {
        const portUsed = await isPortTaken(port, config.hostname);
        if (!portUsed) {
          // eslint-disable-next-line require-atomic-updates
          config.port = port;
          return;
        }
        if (!portRange.permitted) {
          const message = `Port number \`${port}\` is already in use. Would you like to start debugging using \`${port + 1}\`?\n If you don't want to see this message, set a value for \`port\` of \`launch.json\`.`;
          const result = await window.showInformationMessage(message, { modal: true }, 'Yes');
          if (!result) {
            break;
          }
        }
      }

      this.pendingErrors.push(Error('You need an unused `port` to debug.'));
    })();

    // init args
    ((): void => {
      if (!isArray(config.args)) {
        this.pendingErrors.push(Error('`args` must be a array.'));
      }
    })();

    // init env
    ((): void => {
      if (!isPlainObject(config.env)) {
        this.pendingErrors.push(Error('`env` must be a object.'));
        return;
      }

      for (const key in config.env) {
        if (config.env[key] === null) {
          config.env[key] = '';
        }
      }
    })();

    // init stopOnEntry
    ((): void => {
      if (!isBoolean(config.stopOnEntry)) {
        this.pendingErrors.push(Error('`stopOnEntry` must be a boolean.'));
      }
    })();

    // init maxChildren
    ((): void => {
      if (!Number.isInteger(config.maxChildren)) {
        this.pendingErrors.push(Error('`maxChildren` must be a integer.'));
      }
    })();

    // init useIntelliSenseInDebugging
    ((): void => {
      if (!isBoolean(config.useIntelliSenseInDebugging)) {
        this.pendingErrors.push(Error('`useIntelliSenseInDebugging` must be a boolean.'));
      }
    })();

    // init usePerfTips
    ((): void => {
      if (!(isBoolean(config.usePerfTips) || isString(config.usePerfTips) || isPlainObject(config.usePerfTips))) {
        this.pendingErrors.push(Error('`usePerfTips` must be a boolean, a string or a object.'));
        return;
      }

      const defaultUsePerfTips = {
        fontColor: 'gray',
        fontStyle: 'italic',
        format: '{{elapsedTime_s}}s elapsed',
      };

      if (config.usePerfTips === true) {
        config.usePerfTips = defaultUsePerfTips;
        return;
      }
      if (typeof config.usePerfTips === 'string') {
        config.usePerfTips = { format: config.usePerfTips };
        return;
      }
      defaults(config.usePerfTips, defaultUsePerfTips);
    })();

    // init useDebugDirective
    ((): void => {
      if (!(isBoolean(config.useDebugDirective) || isPlainObject(config.useDebugDirective))) {
        this.pendingErrors.push(Error('`useDebugDirective` must be a boolean or a object.'));
        return;
      }
      if (config.useDebugDirective === false) {
        return;
      }

      const defaultDirectiveComment = {
        useBreakpointDirective: true,
        useOutputDirective: true,
      };

      if (config.useDebugDirective === true) {
        config.useDebugDirective = defaultDirectiveComment;
        return;
      }
      defaults(config.useDebugDirective, defaultDirectiveComment);
    })();

    // init trace
    ((): void => {
      if (!isBoolean(config.trace)) {
        this.pendingErrors.push(Error('`trace` must be a boolean.'));
      }
    })();

    // Deprecated. I''ll get rid of it eventually.
    if (config.type === 'ahk') {
      window.showErrorMessage('As of version 1.3.7, the `type` of launch.json has been changed from `ahk` to ` It has been changed to `autohotkey`. Please edit launch.json now. If you do not edit it, you will not be able to debug it in the future.');
      // eslint-disable-next-line require-atomic-updates
      config.type = 'autohotkey';
    }
    return config;
  }
  public resolveDebugConfigurationWithSubstitutedVariables(folder: WorkspaceFolder | undefined, config: DebugConfiguration, token?: CancellationToken): DebugConfiguration {
    if (0 < this.pendingErrors.length) {
      throw this.pendingErrors[0];
    }

    // init runtime
    ((): void => {
      if (typeof config.runtime === 'undefined') {
        const editor = window.activeTextEditor;
        config.runtime = editor && editor.document.languageId.toLowerCase() === 'ahk'
          ? config.runtime_v1
          : config.runtime_v2; // ahk2 or ah2
      }

      if (isString(config.runtime)) {
        if (!path.isAbsolute(config.runtime)) {
          const ahkPath = `${String(process.env.PROGRAMFILES)}/AutoHotkey`;
          config.runtime = path.resolve(ahkPath, config.runtime);
        }
        if (path.extname(config.runtime) === '') {
          config.runtime += '.exe';
        }
        return;
      }

      throw Error('`runtime` must be a string.');
    })();

    // init runtimeArgs
    ((): void => {
      if (typeof config.runtimeArgs === 'undefined') {
        if (!existsSync(config.runtime)) {
          throw Error(`\`runtime\` must be a file path that exists.\nSpecified: \`${String(path.normalize(config.runtime))}\``);
        }
        const ahkVersion = getAhkVersion(config.runtime, { env: config.env });
        if (ahkVersion === null) {
          throw Error(`\`runtime\` is not AutoHotkey runtime.\nSpecified: \`${String(path.normalize(config.runtime))}\``);
        }

        if (typeof config.runtimeArgs_v1 === 'undefined') {
          config.runtimeArgs_v1 = ahkVersion.mejor === 1 && ahkVersion.minor === 1 && 33 <= ahkVersion.teeny
            ? [ '/ErrorStdOut=UTF-8' ]
            : [ '/ErrorStdOut' ];
        }
        if (typeof config.runtimeArgs_v2 === 'undefined') {
          config.runtimeArgs_v2 = ahkVersion.alpha && 112 <= ahkVersion.alpha
            ? [ '/ErrorStdOut=UTF-8' ]
            : [ '/ErrorStdOut' ];
        }

        const editor = window.activeTextEditor;
        config.runtimeArgs = editor && editor.document.languageId.toLowerCase() === 'ahk'
          ? config.runtimeArgs_v1
          : config.runtimeArgs_v2; // ahk2 or ah2

        config.runtimeArgs = config.runtimeArgs.filter((arg) => arg.search(/\/debug/ui) === -1);
        config.runtimeArgs = config.runtimeArgs.filter((arg) => arg !== ''); // If a blank character is set here, AutoHotkey cannot be started. It is confusing for users to pass an empty string as an argument and generate an error, so fix it here.
      }

      if (isArray(config.runtimeArgs)) {
        return;
      }
      throw Error('`runtimeArgs` must be a array.');
    })();

    // init program
    ((): void => {
      if (!isString(config.program)) {
        throw Error('`program` must be a string.');
      }
      if (!existsSync(config.program)) {
        throw Error(`\`program\` must be a file path that exists.\nSpecified: \`${String(path.normalize(config.program))}\``);
      }
    })();

    // init openFileOnExit
    ((): void => {
      if (!isString(config.openFileOnExit)) {
        throw Error('`openFileOnExit` must be a string.');
      }
      if (!existsSync(config.openFileOnExit)) {
        throw Error(`\`openFileOnExit\` must be a file path that exists.\nSpecified: \`${String(path.normalize(config.openFileOnExit))}\``);
      }
    })();

    return config;
  }
}
class InlineDebugAdapterFactory implements DebugAdapterDescriptorFactory {
  public createDebugAdapterDescriptor(_session: DebugSession): ProviderResult<DebugAdapterDescriptor> {
    return new DebugAdapterInlineImplementation(new AhkDebugSession());
  }
}

export const activate = function(context: ExtensionContext): void {
  const provider = new AhkConfigurationProvider();

  context.subscriptions.push(debug.registerDebugConfigurationProvider('ahk', provider));
  context.subscriptions.push(debug.registerDebugConfigurationProvider('autohotkey', provider));
  context.subscriptions.push(debug.registerDebugAdapterDescriptorFactory('autohotkey', new InlineDebugAdapterFactory()));

  context.subscriptions.push(languages.registerCompletionItemProvider([ 'ahk', 'ahk2', 'ah2', 'autohotkey' ], completionItemProvider, '.'));
};
